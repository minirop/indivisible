use std::process::Command;
use std::path::Path;
use std::io::SeekFrom;
use byteorder::ReadBytesExt;
use byteorder::BigEndian;
use std::fs::File;
use std::io;
use std::io::Seek;
use std::io::Read;
use std::io::Write;
use std::io::Result;
use lz4::Decoder;
use clap::Parser;

/// Handles files from the game Indivisible
#[derive(Parser, Debug)]
#[command(author = None, version = None, about = None, long_about = None)]
struct Args {
    /// Input file or directory
    input: String,

    #[arg(short = 'x', long)]
    extract: bool,

    #[arg(short, long)]
    decrypt: bool,

    /// Output file or directory
    #[arg(short, long)]
    output: String,
}

struct Entry {
    filename: String,
    size: usize,
}

fn main() -> Result<()> {
    let args = Args::parse();

    if args.decrypt {
        decypher(&args.input, &args.output)?;
    } else if args.extract {
        extract(&args.input, &args.output)?;
    }

    Ok(())
}

fn extract(input_file: &str, dir: &str) -> Result<()> {
    let mut f = File::open(&input_file).unwrap();
    let start = f.read_u32::<BigEndian>()? as u64;

    if start > f.metadata()?.len() {
        panic!("CORRUPTED FILE: {}", input_file);
    }

    f.seek(SeekFrom::Start(0x33))?;

    let mut files = vec![];

    while f.stream_position()? < start {
        let _unk1 = f.read_u32::<BigEndian>()?;
        let name_length = f.read_u32::<BigEndian>()? as usize;

        let mut buff = vec![0u8; name_length];
        f.read(&mut buff).unwrap();
        let filename = String::from_utf8(buff).unwrap();

        let unk2 = f.read_u32::<BigEndian>()?; assert_eq!(unk2, 0);
        let size = f.read_u32::<BigEndian>()? as usize;
        let one = f.read_u32::<BigEndian>()?; assert_eq!(one, 1);

        let output = format!("{}/{}", dir, filename);
        let path = Path::new(&output);
        let directory = path.parent().unwrap();
        std::fs::create_dir_all(directory).unwrap();

        files.push(Entry {
            filename: output,
            size,
        });
    }

    assert_eq!(f.stream_position()?, start);

    println!("{} files", files.len());
    for file in files {
        let mut buff = vec![0u8; file.size];
        f.read(&mut buff).unwrap();

        std::fs::write(&file.filename, buff).unwrap();

        if file.filename.ends_with(".lz4") {
            let p = Path::new(&file.filename).with_extension("");
            let uncomp = p.as_path().to_str().unwrap();
            unlz4(&file.filename, uncomp)?;
            std::fs::remove_file(&file.filename)?;

            if uncomp.ends_with(".dds") {
                let png = Path::new(uncomp).with_extension("png");
                let png = png.as_path().to_str().unwrap();
                Command::new("convert")
                    .arg(uncomp)
                    .arg(png)
                    .status()
                    .expect("convert command failed to start");
                std::fs::remove_file(uncomp)?;
            }
        }
    }

    Ok(())
}

const DAT_00B6CCA0: [u8; 128] = [
0xE2, 0x71, 0x85, 0x5C,
0xA5, 0xA0, 0xFD, 0x2C,
0x5B, 0xEF, 0x43, 0xEF,
0x5A, 0xBD, 0xF5, 0x54,
0xF6, 0x1E, 0xF7, 0x16,
0x35, 0x29, 0x15, 0x65,
0xE5, 0x9C, 0x28, 0x9B,
0xE0, 0x5C, 0xE5, 0xAA,
0x10, 0x30, 0x81, 0x57,
0x2D, 0xD5, 0x04, 0x56,
0x18, 0x19, 0xEB, 0x7C,
0xB8, 0x62, 0x20, 0xEC,
0x63, 0x8D, 0x94, 0x9C,
0x71, 0x1B, 0x33, 0x8A,
0x98, 0xA3, 0x2D, 0xF2,
0xA1, 0xD8, 0xB7, 0xEB,
0xD6, 0x15, 0x45, 0xF4,
0x7F, 0x7E, 0x45, 0x88,
0x3A, 0x1B, 0xE6, 0x8E,
0x8E, 0x95, 0x14, 0x1C,
0x9C, 0xE0, 0x2F, 0xD7,
0x6C, 0x8C, 0xF4, 0xCF,
0x06, 0x6F, 0xDA, 0x0A,
0xBA, 0xA0, 0xBA, 0x2F,
0xC0, 0x28, 0xB3, 0xAF,
0x55, 0xE3, 0x64, 0x77,
0xB5, 0x83, 0xD2, 0xC3,
0x73, 0x4C, 0x86, 0xDA,
0x62, 0x17, 0x3F, 0xDA,
0x4F, 0x34, 0x66, 0xF6,
0x20, 0x48, 0x52, 0x3C,
0x34, 0xC2, 0x85, 0xD2
];

const DAT_00B6CC20: [u8; 128] = [
0x50, 0x84, 0xC1, 0x0C,
0x8E, 0xC9, 0xDC, 0xB6,
0x1B, 0xA7, 0x40, 0xA1,
0xBB, 0x5F, 0x49, 0xF8,
0x3F, 0x12, 0x02, 0xAA,
0x6E, 0xD7, 0x23, 0x81,
0x41, 0x58, 0xEB, 0x66,
0x20, 0x61, 0x74, 0x25,
0xC4, 0x01, 0xFA, 0x47,
0x52, 0xC6, 0x1E, 0xE5,
0x1C, 0x0B, 0xE1, 0x3F,
0xE9, 0xB9, 0xDB, 0x95,
0x79, 0x4F, 0x1B, 0x1B,
0x03, 0xF8, 0x7A, 0x76,
0x4B, 0x91, 0x15, 0x55,
0x5B, 0x9B, 0x8A, 0xDD,
0x34, 0xF1, 0x7E, 0xA0,
0x44, 0x08, 0xB6, 0xCA,
0x60, 0xDB, 0xD1, 0xCE,
0x31, 0x8E, 0xB6, 0xC3,
0x28, 0x9F, 0xFA, 0x6C,
0x9D, 0xFE, 0x41, 0x7C,
0x57, 0x8D, 0x83, 0xAC,
0xF5, 0xD4, 0xDB, 0xA5,
0xB8, 0xFD, 0x47, 0xBA,
0xA3, 0xA4, 0xCD, 0x15,
0x4C, 0x76, 0x9A, 0xB6,
0x15, 0x0F, 0x20, 0x21,
0xAA, 0x61, 0x1F, 0x67,
0x42, 0xAD, 0x97, 0x89,
0xEE, 0xF9, 0xFB, 0xAC,
0x29, 0x8B, 0xB1, 0x42
];

const DAT_00B6CD20: [u8; 128] = [
0xF4, 0x47, 0x5E, 0x5B,
0xAF, 0xC3, 0xC4, 0xEB,
0x28, 0x96, 0x2B, 0xB9,
0xD7, 0x20, 0x0F, 0x4F,
0x6E, 0xFB, 0x18, 0x27,
0x62, 0xC6, 0x8A, 0x19,
0xFC, 0x5B, 0x4F, 0xF5,
0x48, 0x42, 0x81, 0x4F,
0x84, 0xDF, 0x6E, 0x91,
0x39, 0xBD, 0xA5, 0x39,
0x63, 0x33, 0x62, 0x17,
0x64, 0x6D, 0x67, 0x9B,
0x10, 0x23, 0x6C, 0x50,
0x49, 0xEC, 0x41, 0x97,
0x3C, 0x5D, 0x9E, 0xA9,
0xD3, 0x55, 0x2C, 0xA2,
0xA1, 0xBD, 0xE6, 0x07,
0xF0, 0x25, 0x6B, 0x20,
0xF1, 0xB3, 0x26, 0x4E,
0xAF, 0x0B, 0xD5, 0xD2,
0xA7, 0x60, 0x41, 0xDA,
0x9C, 0x11, 0xDD, 0xC0,
0x1D, 0x0B, 0x48, 0x04,
0x42, 0x7C, 0xB0, 0xE1,
0x9E, 0x71, 0x4A, 0x08,
0x46, 0x24, 0x3E, 0xED,
0xC1, 0x9F, 0xFD, 0x7F,
0xF1, 0xC8, 0x7F, 0x0D,
0x93, 0xB5, 0x07, 0x74,
0xE3, 0xE5, 0xC3, 0x96,
0x4C, 0x63, 0x6C, 0x7E,
0x9B, 0xF4, 0x8C, 0x72
];

fn decypher(input_file: &str, output_file: &str) -> Result<()> {
    let mut f = File::open(&input_file).unwrap();

    let mut dat_13749bf: Vec<u8> = Vec::with_capacity(0x1b2580);

    let mut uvar4 = 0usize;

    while uvar4 < 0x1b2580 {
        let bvar6 = DAT_00B6CD20[uvar4 % 0x7b];
        let bvar3 = DAT_00B6CCA0[uvar4 % 0x71];
        let bvar4 = DAT_00B6CC20[uvar4 & 0x7f];
        dat_13749bf.push(bvar6 ^ bvar3 ^ bvar4);

        uvar4 += 1;
    }

    let len = f.metadata().unwrap().len() as usize;
    let mut index = 0;
    let mut bytes = Vec::with_capacity(len);
    f.read_to_end(&mut bytes)?;
    for i in 0..len {
        bytes[i] ^= dat_13749bf[index];
        index = (index + 1) % dat_13749bf.len();
    }
    let mut out = File::create(&output_file).unwrap();
    out.write(&bytes)?;

    Ok(())
}

#[allow(dead_code)]
fn unlz4(source: &str, destination: &str) -> Result<()> {
    let input_file = File::open(source)?;
    let mut decoder = Decoder::new(input_file)?;
    let mut output_file = File::create(destination)?;
    io::copy(&mut decoder, &mut output_file)?;

    Ok(())
}
